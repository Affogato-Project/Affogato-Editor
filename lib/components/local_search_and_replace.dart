part of affogato.editor;

/// This controller provides a method to control the animations and required
/// show/dismiss operations to interact with the [SearchAndReplaceWidget] in an intra-file
/// context (hence the `Local` prefix).
///
/// In order to correctly implement the mechanism for the search-and-replace overlay, instantiate this
/// class in the [State] object of the parent widget. Pass the [overlayKey] generated by this class to the
/// [Widget.key] property of the [SearchAndReplaceWidget]. Then, call the
class SearchAndReplaceController {
  final bool isLocal;
  final SearchAndReplaceData searchAndReplaceData = SearchAndReplaceData();
  final GlobalKey<SearchAndReplaceWidgetState> overlayKey = GlobalKey();
  late final AnimationController searchAndReplaceAnimationController;
  late final Animation<Offset> searchAndReplaceOffsetAnimation = Tween<Offset>(
    begin: const Offset(0, -1.25),
    end: Offset.zero,
  ).animate(
    CurvedAnimation(
      parent: searchAndReplaceAnimationController,
      curve: Curves.linear,
    ),
  );
  final List<Positioned> searchAndReplaceMatchHighlights = [];
  Iterable<Match> matches = Iterable.empty();
  int searchItemCurrentIndex = 0;
  String searchText = '';
  String? replaceText;
  final VoidCallback? onDismiss;
  final double cellWidth;
  final double cellHeight;

  /// The collection of documents to search
  final SearchableDocumentsScope scope;
  // final TextEditingController? textController;
  double currentItemOffset = 0;
  final String Function() initialSearchText;

  SearchAndReplaceController.local({
    required TickerProvider tickerProvider,
    required this.cellWidth,
    required this.cellHeight,
    required LocalSearchableDocumentsScope localScope,
    this.onDismiss,
  })  : searchAndReplaceAnimationController = AnimationController(
          duration: const Duration(milliseconds: 200),
          vsync: tickerProvider,
        ),
        scope = localScope,
        initialSearchText = (() => localScope.controller.selection.isCollapsed
            ? ''
            : localScope.controller.selection
                .textInside(localScope.controller.text)),
        isLocal = true;

  SearchAndReplaceController.global({
    required TickerProvider tickerProvider,
    required this.cellWidth,
    required this.cellHeight,
    required GlobalSearchableDocumentsScope globalScope,
    this.onDismiss,
  })  : searchAndReplaceAnimationController = AnimationController(
          duration: const Duration(milliseconds: 200),
          vsync: tickerProvider,
        ),
        scope = globalScope,
        initialSearchText = (() => ''),
        isLocal = false;

  void show() {
    searchAndReplaceAnimationController.forward();
    overlayKey.currentState!.searchFieldFocusNode.requestFocus();
    regenerateMatches(
      newText: initialSearchText(),
    );
  }

  void dismiss() {
    searchAndReplaceAnimationController.reverse();
    searchAndReplaceMatchHighlights.clear();
    onDismiss?.call();
  }

  void toggle() {
    if (!(overlayKey.currentState?.mounted ?? false)) return;
    if (isShown) {
      show();
    } else {
      dismiss();
    }
  }

  void nextMatch() {
    if (searchItemCurrentIndex + 1 >= matches.length) {
      searchItemCurrentIndex = 0;
    } else {
      searchItemCurrentIndex += 1;
    }
    searchAndReplaceMatchHighlights
      ..clear()
      ..addAll(
        generateSearchAndReplaceHighlights(
          matches: matches,
          wordWidth: searchText.length,
        ),
      );
  }

  void prevMatch() {
    if (searchItemCurrentIndex - 1 < 0) {
      searchItemCurrentIndex = matches.length - 1;
    } else {
      searchItemCurrentIndex -= 1;
    }
    searchAndReplaceMatchHighlights
      ..clear()
      ..addAll(
        generateSearchAndReplaceHighlights(
          matches: matches,
          wordWidth: searchText.length,
        ),
      );
  }

  void regenerateMatches({
    required String newText,
  }) {
    searchText = newText;
    if (searchText != '') {
      if (scope is LocalSearchableDocumentsScope) {
        matches = searchText.allMatches(
            (scope as LocalSearchableDocumentsScope).controller.text);
        searchAndReplaceMatchHighlights
          ..clear()
          ..addAll(
            generateSearchAndReplaceHighlights(
              matches: matches,
              wordWidth: searchText.length,
            ),
          );
      }
    }
  }

  List<Positioned> generateSearchAndReplaceHighlights({
    required Iterable<Match> matches,
    required int wordWidth,
  }) {
    final List<Positioned> widgets = [];
    for (int i = 0; i < matches.length; i++) {
      final Match match = matches.elementAt(i);
      final double offset = ((scope as LocalSearchableDocumentsScope)
                  .controller
                  .text
                  .substring(0, match.start)
                  .split('\n')
                  .length -
              1) *
          cellHeight;
      widgets.add(
        Positioned(
          key: ValueKey('$searchText-$searchItemCurrentIndex-$i'),
          top: offset,
          left: utils.AffogatoConstants.lineNumbersColWidth +
              utils.AffogatoConstants.lineNumbersGutterWidth +
              charNumAtIndex(match.start,
                      controllerText: (scope as LocalSearchableDocumentsScope)
                          .controller
                          .text) *
                  cellWidth -
              2,
          width: wordWidth * cellWidth + 2,
          child: Container(
            height: cellHeight,
            width: wordWidth * cellWidth,
            color: Colors.orange
                .withOpacity(i == searchItemCurrentIndex ? 0.3 : 0.2),
          ),
        ),
      );
      if (i == searchItemCurrentIndex) currentItemOffset = offset;
    }
    return widgets;
  }

  int charNumAtIndex(int index, {required String controllerText}) {
    int charNum = 0;
    for (int i = 0; i < controllerText.length; i++) {
      if (i == index) return charNum;
      if (controllerText[i] == '\n') {
        charNum = 0;
      } else {
        charNum += 1;
      }
    }
    return charNum;
  }

  bool get isShown => searchAndReplaceAnimationController.value == 0;

  void scrollIfActiveMatchOutsideViewport({
    required double scrollOffset,
    required double viewportHeight,
    required void Function(double) scrollCallback,
  }) {
    if (currentItemOffset > scrollOffset + viewportHeight - 10) {
      scrollCallback(currentItemOffset + 40);
    } else if (currentItemOffset < scrollOffset - viewportHeight + 10) {
      scrollCallback(currentItemOffset - 40);
    }
  }

  void replaceCurrentMatch() {
    if (matches.isNotEmpty && searchText != '' && replaceText != null) {
      (scope as LocalSearchableDocumentsScope).controller.text = (scope
                  as LocalSearchableDocumentsScope)
              .controller
              .text
              .substring(0, matches.elementAt(searchItemCurrentIndex).start) +
          replaceText! +
          (scope as LocalSearchableDocumentsScope)
              .controller
              .text
              .substring(matches.elementAt(searchItemCurrentIndex).end);
      regenerateMatches(newText: searchText);
    }
  }

  void replaceAllMatches() {
    if (matches.isNotEmpty && searchText != '' && replaceText != null) {
      (scope as LocalSearchableDocumentsScope).controller.text =
          (scope as LocalSearchableDocumentsScope).controller.text.replaceAll(
                searchText,
                replaceText!,
              );
      regenerateMatches(newText: searchText);
    }
  }
}

/// This object stores the state/data for the [SearchAndReplaceWidget] in an intra-file
/// context.
class SearchAndReplaceData {
  final List<Positioned> searchAndReplaceMatchHighlights = [];
  int searchItemCurrentIndex = 0;
  Iterable<Match> matches = Iterable.empty();
}

sealed class SearchableDocumentsScope {
  const SearchableDocumentsScope();
}

class LocalSearchableDocumentsScope extends SearchableDocumentsScope {
  final TextEditingController controller;

  const LocalSearchableDocumentsScope({
    required this.controller,
  });
}

class GlobalSearchableDocumentsScope extends SearchableDocumentsScope {
  final List<AffogatoVFSEntity> entities;

  const GlobalSearchableDocumentsScope({
    required this.entities,
  });
}
